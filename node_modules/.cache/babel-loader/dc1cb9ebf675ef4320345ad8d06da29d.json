{"ast":null,"code":"/**\n * A helper function to abstract the logic for choosing which device ID touse.\n * Falls back to fuzzy matching on label if a device ID match is not found.\n *\n * @param {Object} options - The arguments used to match find the preferred device ID from available devices.\n * @param {Array<string>} options.availableDevices - The array of currently available devices to match against.\n * @param {Object} options.matchRegex - The regex to use to find strings appended to the label by the\n * operating system. The matches will be replaced with options.replacement, with the intent of matching\n * the same device that might have a modified label.\n * @param {string} options.userSelectedDeviceId - The device ID the participant prefers to use.\n * @param {string} options.userSelectedDeviceLabel - The label associated with the\n * device ID the participant prefers to use.\n * @param {string} options.replacement - The string to use with options.matchRegex to remove identifies\n * added to the label by the operating system.\n * @returns {string} The preferred device ID to use for media.\n */\nexport function _getUserSelectedDeviceId(_ref) {\n  var availableDevices = _ref.availableDevices,\n      userSelectedDeviceId = _ref.userSelectedDeviceId,\n      userSelectedDeviceLabel = _ref.userSelectedDeviceLabel,\n      matchRegex = _ref.matchRegex,\n      replacement = _ref.replacement;\n  // *: If there is no label at all, there is no need to fall back to checking the label for a fuzzy match.\n  if (!userSelectedDeviceLabel || !userSelectedDeviceId) return userSelectedDeviceId; // *: Prioritize matching the deviceId\n\n  var foundMatchingBasedonDeviceId = availableDevices.find(function (candidate) {\n    return candidate.deviceId === userSelectedDeviceId;\n  });\n  if (foundMatchingBasedonDeviceId) return userSelectedDeviceId;\n  var strippedDeviceLabel = matchRegex ? userSelectedDeviceLabel.replace(matchRegex, replacement) : userSelectedDeviceLabel;\n  var foundMatchBasedOnLabel = availableDevices.find(function (candidate) {\n    var label = candidate.label;\n    if (!label) return false;else if (strippedDeviceLabel === label) return true;\n    var strippedCandidateLabel = label.replace(matchRegex, replacement);\n    return strippedDeviceLabel === strippedCandidateLabel;\n  });\n  return foundMatchBasedOnLabel ? foundMatchBasedOnLabel.deviceId : userSelectedDeviceId;\n} // *_: Camera\n\n/**\n * Searches known devices for a matching deviceId and fall back to matching on label.\n * Returns the stored preferred cameraDeviceId if a match is not found.\n */\n\nexport function getUserSelectedCameraDeviceId(videoInputDevices, userSelectedCameraDevice) {\n  return _getUserSelectedDeviceId({\n    availableDevices: videoInputDevices,\n    // Operating systems may append \" #{number}\" somewhere in the label so\n    // find and strip that bit.\n    matchRegex: /\\s#\\d*(?!.*\\s#\\d*)/,\n    userSelectedDeviceId: userSelectedCameraDevice && userSelectedCameraDevice.deviceId || undefined,\n    userSelectedDeviceLabel: userSelectedCameraDevice && userSelectedCameraDevice.label || undefined,\n    replacement: ''\n  });\n} // *_: Mic / Audio input\n\n/**\n * Searches known devices for a matching deviceId and fall back to matching on label.\n * Returns the stored preferred micDeviceId if a match is not found.\n */\n\nexport function getUserSelectedAudioInputDeviceId(audioInputDevices, userSelectedAudioInputDevice) {\n  return _getUserSelectedDeviceId({\n    availableDevices: audioInputDevices,\n    // Operating systems may append \" ({number}-\" somewhere in the label so\n    // find and strip that bit.\n    matchRegex: /\\s\\(\\d*-\\s(?!.*\\s\\(\\d*-\\s)/,\n    userSelectedDeviceId: userSelectedAudioInputDevice && userSelectedAudioInputDevice.deviceId || undefined,\n    userSelectedDeviceLabel: userSelectedAudioInputDevice && userSelectedAudioInputDevice.label || undefined,\n    replacement: ' ('\n  });\n} // *_: Speaker / Audio output\n\n/**\n * Searches known devices for a matching deviceId and fall back to matching on label.\n * Returns the stored preferred audioOutputDeviceId if a match is not found.\n */\n\nexport function getUserSelectedOutputDeviceId(audioOutputDevices, userSelectedAudioOutputDevice) {\n  return _getUserSelectedDeviceId({\n    availableDevices: audioOutputDevices,\n    matchRegex: undefined,\n    userSelectedDeviceId: userSelectedAudioOutputDevice && userSelectedAudioOutputDevice.deviceId || undefined,\n    userSelectedDeviceLabel: userSelectedAudioOutputDevice && userSelectedAudioOutputDevice.label || undefined,\n    replacement: undefined\n  });\n}","map":{"version":3,"sources":["/home/sang/js/cfr-frontend/src/pages/conference2/jitsi/devices/utils.ts"],"names":["_getUserSelectedDeviceId","availableDevices","userSelectedDeviceId","userSelectedDeviceLabel","matchRegex","replacement","foundMatchingBasedonDeviceId","find","candidate","deviceId","strippedDeviceLabel","replace","foundMatchBasedOnLabel","label","strippedCandidateLabel","getUserSelectedCameraDeviceId","videoInputDevices","userSelectedCameraDevice","undefined","getUserSelectedAudioInputDeviceId","audioInputDevices","userSelectedAudioInputDevice","getUserSelectedOutputDeviceId","audioOutputDevices","userSelectedAudioOutputDevice"],"mappings":"AAEA;;;;;;;;;;;;;;;;AAgBA,OAAO,SAASA,wBAAT,OAMJ;AAAA,MALDC,gBAKC,QALDA,gBAKC;AAAA,MAJDC,oBAIC,QAJDA,oBAIC;AAAA,MAHDC,uBAGC,QAHDA,uBAGC;AAAA,MAFDC,UAEC,QAFDA,UAEC;AAAA,MADDC,WACC,QADDA,WACC;AACD;AACA,MAAI,CAACF,uBAAD,IAA4B,CAACD,oBAAjC,EAAuD,OAAOA,oBAAP,CAFtD,CAID;;AACA,MAAMI,4BAA4B,GAAGL,gBAAgB,CAACM,IAAjB,CAAsB,UAAAC,SAAS;AAAA,WAAIA,SAAS,CAACC,QAAV,KAAuBP,oBAA3B;AAAA,GAA/B,CAArC;AACA,MAAII,4BAAJ,EAAkC,OAAOJ,oBAAP;AAElC,MAAMQ,mBAAmB,GAAGN,UAAU,GAClCD,uBAAuB,CAACQ,OAAxB,CAAgCP,UAAhC,EAA4CC,WAA5C,CADkC,GAElCF,uBAFJ;AAIA,MAAMS,sBAAsB,GAAGX,gBAAgB,CAACM,IAAjB,CAAsB,UAAAC,SAAS,EAAI;AAAA,QACxDK,KADwD,GAC9CL,SAD8C,CACxDK,KADwD;AAGhE,QAAI,CAACA,KAAL,EAAY,OAAO,KAAP,CAAZ,KACK,IAAIH,mBAAmB,KAAKG,KAA5B,EAAmC,OAAO,IAAP;AAExC,QAAMC,sBAAsB,GAAGD,KAAK,CAACF,OAAN,CAAcP,UAAd,EAA0BC,WAA1B,CAA/B;AAEA,WAAOK,mBAAmB,KAAKI,sBAA/B;AACD,GAT8B,CAA/B;AAWA,SAAOF,sBAAsB,GAAGA,sBAAsB,CAACH,QAA1B,GAAqCP,oBAAlE;AACD,C,CAED;;AAEA;;;;;AAIA,OAAO,SAASa,6BAAT,CACLC,iBADK,EAELC,wBAFK,EAGL;AACA,SAAOjB,wBAAwB,CAAC;AAC9BC,IAAAA,gBAAgB,EAAEe,iBADY;AAG9B;AACA;AACAZ,IAAAA,UAAU,EAAE,oBALkB;AAM9BF,IAAAA,oBAAoB,EAAGe,wBAAwB,IAAIA,wBAAwB,CAACR,QAAtD,IAAmES,SAN3D;AAO9Bf,IAAAA,uBAAuB,EAAGc,wBAAwB,IAAIA,wBAAwB,CAACJ,KAAtD,IAAgEK,SAP3D;AAQ9Bb,IAAAA,WAAW,EAAE;AARiB,GAAD,CAA/B;AAUD,C,CAED;;AAEA;;;;;AAIA,OAAO,SAASc,iCAAT,CACLC,iBADK,EAELC,4BAFK,EAGL;AACA,SAAOrB,wBAAwB,CAAC;AAC9BC,IAAAA,gBAAgB,EAAEmB,iBADY;AAG9B;AACA;AACAhB,IAAAA,UAAU,EAAE,4BALkB;AAM9BF,IAAAA,oBAAoB,EAAGmB,4BAA4B,IAAIA,4BAA4B,CAACZ,QAA9D,IAA2ES,SANnE;AAO9Bf,IAAAA,uBAAuB,EAAGkB,4BAA4B,IAAIA,4BAA4B,CAACR,KAA9D,IAAwEK,SAPnE;AAQ9Bb,IAAAA,WAAW,EAAE;AARiB,GAAD,CAA/B;AAUD,C,CAED;;AAEA;;;;;AAIA,OAAO,SAASiB,6BAAT,CACLC,kBADK,EAELC,6BAFK,EAGL;AACA,SAAOxB,wBAAwB,CAAC;AAC9BC,IAAAA,gBAAgB,EAAEsB,kBADY;AAE9BnB,IAAAA,UAAU,EAAEc,SAFkB;AAG9BhB,IAAAA,oBAAoB,EAAGsB,6BAA6B,IAAIA,6BAA6B,CAACf,QAAhE,IAA6ES,SAHrE;AAI9Bf,IAAAA,uBAAuB,EAAGqB,6BAA6B,IAAIA,6BAA6B,CAACX,KAAhE,IAA0EK,SAJrE;AAK9Bb,IAAAA,WAAW,EAAEa;AALiB,GAAD,CAA/B;AAOD","sourcesContent":["import { MediaDevice } from '.'\n\n/**\n * A helper function to abstract the logic for choosing which device ID touse.\n * Falls back to fuzzy matching on label if a device ID match is not found.\n *\n * @param {Object} options - The arguments used to match find the preferred device ID from available devices.\n * @param {Array<string>} options.availableDevices - The array of currently available devices to match against.\n * @param {Object} options.matchRegex - The regex to use to find strings appended to the label by the\n * operating system. The matches will be replaced with options.replacement, with the intent of matching\n * the same device that might have a modified label.\n * @param {string} options.userSelectedDeviceId - The device ID the participant prefers to use.\n * @param {string} options.userSelectedDeviceLabel - The label associated with the\n * device ID the participant prefers to use.\n * @param {string} options.replacement - The string to use with options.matchRegex to remove identifies\n * added to the label by the operating system.\n * @returns {string} The preferred device ID to use for media.\n */\nexport function _getUserSelectedDeviceId({\n  availableDevices,\n  userSelectedDeviceId,\n  userSelectedDeviceLabel,\n  matchRegex,\n  replacement\n}) {\n  // *: If there is no label at all, there is no need to fall back to checking the label for a fuzzy match.\n  if (!userSelectedDeviceLabel || !userSelectedDeviceId) return userSelectedDeviceId\n\n  // *: Prioritize matching the deviceId\n  const foundMatchingBasedonDeviceId = availableDevices.find(candidate => candidate.deviceId === userSelectedDeviceId)\n  if (foundMatchingBasedonDeviceId) return userSelectedDeviceId\n\n  const strippedDeviceLabel = matchRegex\n    ? userSelectedDeviceLabel.replace(matchRegex, replacement)\n    : userSelectedDeviceLabel\n\n  const foundMatchBasedOnLabel = availableDevices.find(candidate => {\n    const { label } = candidate\n\n    if (!label) return false\n    else if (strippedDeviceLabel === label) return true\n\n    const strippedCandidateLabel = label.replace(matchRegex, replacement)\n\n    return strippedDeviceLabel === strippedCandidateLabel\n  })\n\n  return foundMatchBasedOnLabel ? foundMatchBasedOnLabel.deviceId : userSelectedDeviceId\n}\n\n// *_: Camera\n\n/**\n * Searches known devices for a matching deviceId and fall back to matching on label.\n * Returns the stored preferred cameraDeviceId if a match is not found.\n */\nexport function getUserSelectedCameraDeviceId(\n  videoInputDevices: Array<MediaDevice>,\n  userSelectedCameraDevice: MediaDevice\n) {\n  return _getUserSelectedDeviceId({\n    availableDevices: videoInputDevices,\n\n    // Operating systems may append \" #{number}\" somewhere in the label so\n    // find and strip that bit.\n    matchRegex: /\\s#\\d*(?!.*\\s#\\d*)/,\n    userSelectedDeviceId: (userSelectedCameraDevice && userSelectedCameraDevice.deviceId) || undefined,\n    userSelectedDeviceLabel: (userSelectedCameraDevice && userSelectedCameraDevice.label) || undefined,\n    replacement: ''\n  })\n}\n\n// *_: Mic / Audio input\n\n/**\n * Searches known devices for a matching deviceId and fall back to matching on label.\n * Returns the stored preferred micDeviceId if a match is not found.\n */\nexport function getUserSelectedAudioInputDeviceId(\n  audioInputDevices: Array<MediaDevice>,\n  userSelectedAudioInputDevice: MediaDevice\n) {\n  return _getUserSelectedDeviceId({\n    availableDevices: audioInputDevices,\n\n    // Operating systems may append \" ({number}-\" somewhere in the label so\n    // find and strip that bit.\n    matchRegex: /\\s\\(\\d*-\\s(?!.*\\s\\(\\d*-\\s)/,\n    userSelectedDeviceId: (userSelectedAudioInputDevice && userSelectedAudioInputDevice.deviceId) || undefined,\n    userSelectedDeviceLabel: (userSelectedAudioInputDevice && userSelectedAudioInputDevice.label) || undefined,\n    replacement: ' ('\n  })\n}\n\n// *_: Speaker / Audio output\n\n/**\n * Searches known devices for a matching deviceId and fall back to matching on label.\n * Returns the stored preferred audioOutputDeviceId if a match is not found.\n */\nexport function getUserSelectedOutputDeviceId(\n  audioOutputDevices: Array<MediaDevice>,\n  userSelectedAudioOutputDevice: MediaDevice\n) {\n  return _getUserSelectedDeviceId({\n    availableDevices: audioOutputDevices,\n    matchRegex: undefined,\n    userSelectedDeviceId: (userSelectedAudioOutputDevice && userSelectedAudioOutputDevice.deviceId) || undefined,\n    userSelectedDeviceLabel: (userSelectedAudioOutputDevice && userSelectedAudioOutputDevice.label) || undefined,\n    replacement: undefined\n  })\n}\n"]},"metadata":{},"sourceType":"module"}