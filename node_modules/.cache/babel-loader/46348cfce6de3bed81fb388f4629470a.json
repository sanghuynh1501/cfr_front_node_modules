{"ast":null,"code":"import { normalizeNFKC } from './strings';\n/**\n * The app linking scheme.\n * TODO: This should be read from the manifest files later.\n */\n\nexport var APP_LINK_SCHEME = 'org.jitsi.meet:';\n/**\n * A list of characters to be excluded/removed from the room component/segment\n * of a conference/meeting URI/URL. The list is based on RFC 3986 and the jxmpp\n * library utilized by jicofo.\n */\n\nvar _ROOM_EXCLUDE_PATTERN = '[\\\\:\\\\?#\\\\[\\\\]@!$&\\'()*+,;=></\"]';\n/**\n * The {@link RegExp} pattern of the authority of a URI.\n *\n * @private\n * @type {string}\n */\n\nvar _URI_AUTHORITY_PATTERN = '(//[^/?#]+)';\n/**\n * The {@link RegExp} pattern of the path of a URI.\n *\n * @private\n * @type {string}\n */\n\nvar _URI_PATH_PATTERN = '([^?#]*)';\n/**\n * The {@link RegExp} pattern of the protocol of a URI.\n *\n * FIXME: The URL class exposed by JavaScript will not include the colon in\n * the protocol field. Also in other places (at the time of this writing:\n * the DeepLinkingMobilePage.js) the APP_LINK_SCHEME does not include\n * the double dots, so things are inconsistent.\n *\n * @type {string}\n */\n\nexport var URI_PROTOCOL_PATTERN = '^([a-z][a-z0-9\\\\.\\\\+-]*:)';\n/**\n * Excludes/removes certain characters from a specific room (name) which are\n * incompatible with Jitsi Meet on the client and/or server sides.\n *\n * @param {?string} room - The room (name) to fix.\n * @private\n * @returns {?string}\n */\n\nfunction _fixRoom(room) {\n  return room ? room.replace(new RegExp(_ROOM_EXCLUDE_PATTERN, 'g'), '') : room;\n}\n/**\n * Fixes the scheme part of a specific URI (string) so that it contains a\n * well-known scheme such as HTTP(S). For example, the mobile app implements an\n * app-specific URI scheme in addition to Universal Links. The app-specific\n * scheme may precede or replace the well-known scheme. In such a case, dealing\n * with the app-specific scheme only complicates the logic and it is simpler to\n * get rid of it (by translating the app-specific scheme into a well-known\n * scheme).\n *\n * @param {string} uri - The URI (string) to fix the scheme of.\n * @private\n * @returns {string}\n */\n\n\nfunction _fixURIStringScheme(uri) {\n  var regex = new RegExp(\"\".concat(URI_PROTOCOL_PATTERN, \"+\"), 'gi');\n  var match = regex.exec(uri);\n\n  if (match) {\n    // As an implementation convenience, pick up the last scheme and make\n    // sure that it is a well-known one.\n    var protocol = match[match.length - 1].toLowerCase();\n\n    if (protocol !== 'http:' && protocol !== 'https:') {\n      protocol = 'https:';\n    }\n    /* eslint-disable no-param-reassign */\n\n\n    uri = uri.substring(regex.lastIndex);\n\n    if (uri.startsWith('//')) {\n      // The specified URL was not a room name only, it contained an\n      // authority.\n      uri = protocol + uri;\n    }\n    /* eslint-enable no-param-reassign */\n\n  }\n\n  return uri;\n}\n/**\n * Converts a room name to a backend-safe format. Properly lowercased and url encoded.\n *\n * @param {string?} room - The room name to convert.\n * @returns {string?}\n */\n\n\nexport function getBackendSafeRoomName(room) {\n  if (!room) {\n    return room;\n  }\n  /* eslint-disable no-param-reassign */\n\n\n  try {\n    // We do not know if we get an already encoded string at this point\n    // as different platforms do it differently, but we need a decoded one\n    // for sure. However since decoding a non-encoded string is a noop, we're safe\n    // doing it here.\n    room = decodeURIComponent(room);\n  } catch (e) {} // This can happen though if we get an unencoded string and it contains\n  // some characters that look like an encoded entity, but it's not.\n  // But in this case we're fine goin on...\n  // Normalize the character set.\n\n\n  room = normalizeNFKC(room); // Only decoded and normalized strings can be lowercased properly.\n\n  room = room.toLowerCase(); // But we still need to (re)encode it.\n\n  room = encodeURIComponent(room);\n  /* eslint-enable no-param-reassign */\n  // Unfortunately we still need to lowercase it, because encoding a string will\n  // add some uppercase characters, but some backend services\n  // expect it to be full lowercase. However lowercasing an encoded string\n  // doesn't change the string value.\n\n  return room.toLowerCase();\n}\n/**\n * Gets the (Web application) context root defined by a specific location (URI).\n *\n * @param {Object} location - The location (URI) which defines the (Web\n * application) context root.\n * @public\n * @returns {string} - The (Web application) context root defined by the\n * specified {@code location} (URI).\n */\n\nexport function getLocationContextRoot(_ref) {\n  var pathname = _ref.pathname;\n  var contextRootEndIndex = pathname.lastIndexOf('/');\n  return contextRootEndIndex === -1 ? '/' : pathname.substring(0, contextRootEndIndex + 1);\n}\n/**\n * Constructs a new {@code Array} with URL parameter {@code String}s out of a\n * specific {@code Object}.\n *\n * @param {Object} obj - The {@code Object} to turn into URL parameter\n * {@code String}s.\n * @returns {Array<string>} The {@code Array} with URL parameter {@code String}s\n * constructed out of the specified {@code obj}.\n */\n\nfunction _objectToURLParamsArray() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var params = [];\n\n  for (var key in obj) {\n    // eslint-disable-line guard-for-in\n    try {\n      params.push(\"\".concat(key, \"=\").concat(encodeURIComponent(JSON.stringify(obj[key]))));\n    } catch (e) {\n      console.warn(\"Error encoding \".concat(key, \": \").concat(e));\n    }\n  }\n\n  return params;\n}\n/**\n * Parses a specific URI string into an object with the well-known properties of\n * the {@link Location} and/or {@link URL} interfaces implemented by Web\n * browsers. The parsing attempts to be in accord with IETF's RFC 3986.\n *\n * @param {string} str - The URI string to parse.\n * @public\n * @returns {{\n *     hash: string,\n *     host: (string|undefined),\n *     hostname: (string|undefined),\n *     pathname: string,\n *     port: (string|undefined),\n *     protocol: (string|undefined),\n *     search: string\n * }}\n */\n\n\nexport function parseStandardURIString(str) {\n  /* eslint-disable no-param-reassign */\n  var obj = {\n    toString: _standardURIToString\n  };\n  var regex;\n  var match; // XXX A URI string as defined by RFC 3986 does not contain any whitespace.\n  // Usually, a browser will have already encoded any whitespace. In order to\n  // avoid potential later problems related to whitespace in URI, strip any\n  // whitespace. Anyway, the Jitsi Meet app is not known to utilize unencoded\n  // whitespace so the stripping is deemed safe.\n\n  str = str.replace(/\\s/g, ''); // protocol\n\n  regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');\n  match = regex.exec(str);\n\n  if (match) {\n    obj.protocol = match[1].toLowerCase();\n    str = str.substring(regex.lastIndex);\n  } // authority\n\n\n  regex = new RegExp(\"^\".concat(_URI_AUTHORITY_PATTERN), 'gi');\n  match = regex.exec(str);\n\n  if (match) {\n    var authority = match[1].substring(\n    /* // */\n    2);\n    str = str.substring(regex.lastIndex); // userinfo\n\n    var userinfoEndIndex = authority.indexOf('@');\n\n    if (userinfoEndIndex !== -1) {\n      authority = authority.substring(userinfoEndIndex + 1);\n    }\n\n    obj.host = authority; // port\n\n    var portBeginIndex = authority.lastIndexOf(':');\n\n    if (portBeginIndex !== -1) {\n      obj.port = authority.substring(portBeginIndex + 1);\n      authority = authority.substring(0, portBeginIndex);\n    } // hostname\n\n\n    obj.hostname = authority;\n  } // pathname\n\n\n  regex = new RegExp(\"^\".concat(_URI_PATH_PATTERN), 'gi');\n  match = regex.exec(str);\n  var pathname;\n\n  if (match) {\n    pathname = match[1];\n    str = str.substring(regex.lastIndex);\n  }\n\n  if (pathname) {\n    pathname.startsWith('/') || (pathname = \"/\".concat(pathname));\n  } else {\n    pathname = '/';\n  }\n\n  obj.pathname = pathname; // query\n\n  if (str.startsWith('?')) {\n    var hashBeginIndex = str.indexOf('#', 1);\n\n    if (hashBeginIndex === -1) {\n      hashBeginIndex = str.length;\n    }\n\n    obj.search = str.substring(0, hashBeginIndex);\n    str = str.substring(hashBeginIndex);\n  } else {\n    obj.search = ''; // Google Chrome\n  } // fragment\n\n\n  obj.hash = str.startsWith('#') ? str : '';\n  /* eslint-enable no-param-reassign */\n\n  return obj;\n}\n/**\n * Parses a specific URI which (supposedly) references a Jitsi Meet resource\n * (location).\n *\n * @param {(string|undefined)} uri - The URI to parse which (supposedly)\n * references a Jitsi Meet resource (location).\n * @public\n * @returns {{\n *     contextRoot: string,\n *     hash: string,\n *     host: string,\n *     hostname: string,\n *     pathname: string,\n *     port: string,\n *     protocol: string,\n *     room: (string|undefined),\n *     search: string\n * }}\n */\n\nexport function parseURIString(uri) {\n  if (typeof uri !== 'string') {\n    return undefined;\n  }\n\n  var obj = parseStandardURIString(_fixURIStringScheme(uri)); // Add the properties that are specific to a Jitsi Meet resource (location)\n  // such as contextRoot, room:\n  // contextRoot\n\n  obj.contextRoot = getLocationContextRoot(obj); // The room (name) is the last component/segment of pathname.\n\n  var pathname = obj.pathname; // XXX While the components/segments of pathname are URI encoded, Jitsi Meet\n  // on the client and/or server sides still don't support certain characters.\n\n  var contextRootEndIndex = pathname.lastIndexOf('/');\n  var room = pathname.substring(contextRootEndIndex + 1) || undefined;\n\n  if (room) {\n    var fixedRoom = _fixRoom(room);\n\n    if (fixedRoom !== room) {\n      room = fixedRoom; // XXX Drive fixedRoom into pathname (because room is derived from\n      // pathname).\n\n      obj.pathname = pathname.substring(0, contextRootEndIndex + 1) + (room || '');\n    }\n  }\n\n  obj.room = room;\n  return obj;\n}\n/**\n * Implements {@code href} and {@code toString} for the {@code Object} returned\n * by {@link #parseStandardURIString}.\n *\n * @param {Object} [thiz] - An {@code Object} returned by\n * {@code #parseStandardURIString} if any; otherwise, it is presumed that the\n * function is invoked on such an instance.\n * @returns {string}\n */\n\nfunction _standardURIToString(thiz) {\n  // eslint-disable-next-line no-invalid-this\n  var _ref2 = thiz || this,\n      hash = _ref2.hash,\n      host = _ref2.host,\n      pathname = _ref2.pathname,\n      protocol = _ref2.protocol,\n      search = _ref2.search;\n\n  var str = '';\n  protocol && (str += protocol); // TODO userinfo\n\n  host && (str += \"//\".concat(host));\n  str += pathname || '/';\n  search && (str += search);\n  hash && (str += hash);\n  return str;\n}\n/**\n * Sometimes we receive strings that we don't know if already percent-encoded, or not, due to the\n * various sources we get URLs or room names. This function encapsulates the decoding in a safe way.\n *\n * @param {string} text - The text to decode.\n * @returns {string}\n */\n\n\nexport function safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {// The text wasn't encoded.\n  }\n\n  return text;\n}\n/**\n * Attempts to return a {@code String} representation of a specific\n * {@code Object} which is supposed to represent a URL. Obviously, if a\n * {@code String} is specified, it is returned. If a {@code URL} is specified,\n * its {@code URL#href} is returned. Additionally, an {@code Object} similar to\n * the one accepted by the constructor of Web's ExternalAPI is supported on both\n * mobile/React Native and Web/React.\n *\n * @param {Object|string} obj - The URL to return a {@code String}\n * representation of.\n * @returns {string} - A {@code String} representation of the specified\n * {@code obj} which is supposed to represent a URL.\n */\n\nexport function toURLString(obj) {\n  var str; // eslint-disable-next-line default-case\n\n  switch (typeof obj) {\n    case 'object':\n      if (obj) {\n        if (obj instanceof URL) {\n          str = obj.href;\n        } else {\n          str = urlObjectToString(obj);\n        }\n      }\n\n      break;\n\n    case 'string':\n      str = String(obj);\n      break;\n  }\n\n  return str;\n}\n/**\n * Attempts to return a {@code String} representation of a specific\n * {@code Object} similar to the one accepted by the constructor\n * of Web's ExternalAPI.\n *\n * @param {Object} o - The URL to return a {@code String} representation of.\n * @returns {string} - A {@code String} representation of the specified\n * {@code Object}.\n */\n\nexport function urlObjectToString(o) {\n  // First normalize the given url. It come as o.url or split into o.serverURL\n  // and o.room.\n  var tmp;\n\n  if (o.serverURL && o.room) {\n    tmp = new URL(o.room, o.serverURL).toString();\n  } else if (o.room) {\n    tmp = o.room;\n  } else {\n    tmp = o.url || '';\n  }\n\n  var url = parseStandardURIString(_fixURIStringScheme(tmp)); // protocol\n\n  if (!url.protocol) {\n    var protocol = o.protocol || o.scheme;\n\n    if (protocol) {\n      // Protocol is supposed to be the scheme and the final ':'. Anyway,\n      // do not make a fuss if the final ':' is not there.\n      protocol.endsWith(':') || (protocol += ':');\n      url.protocol = protocol;\n    }\n  } // authority & pathname\n\n\n  var pathname = url.pathname;\n\n  if (!url.host) {\n    // Web's ExternalAPI domain\n    //\n    // It may be host/hostname and pathname with the latter denoting the\n    // tenant.\n    var domain = o.domain || o.host || o.hostname;\n\n    if (domain) {\n      var _parseStandardURIStri = parseStandardURIString( // XXX The value of domain in supposed to be host/hostname\n      // and, optionally, pathname. Make sure it is not taken for\n      // a pathname only.\n      _fixURIStringScheme(\"\".concat(APP_LINK_SCHEME, \"//\").concat(domain))),\n          host = _parseStandardURIStri.host,\n          hostname = _parseStandardURIStri.hostname,\n          contextRoot = _parseStandardURIStri.pathname,\n          port = _parseStandardURIStri.port; // authority\n\n\n      if (host) {\n        url.host = host;\n        url.hostname = hostname;\n        url.port = port;\n      } // pathname\n\n\n      pathname === '/' && contextRoot !== '/' && (pathname = contextRoot);\n    }\n  } // pathname\n  // Web's ExternalAPI roomName\n\n\n  var room = o.roomName || o.room;\n\n  if (room && (url.pathname.endsWith('/') || !url.pathname.endsWith(\"/\".concat(room)))) {\n    pathname.endsWith('/') || (pathname += '/');\n    pathname += room;\n  }\n\n  url.pathname = pathname; // query/search\n  // Web's ExternalAPI jwt\n\n  var jwt = o.jwt;\n\n  if (jwt) {\n    var search = url.search;\n\n    if (search.indexOf('?jwt=') === -1 && search.indexOf('&jwt=') === -1) {\n      search.startsWith('?') || (search = \"?\".concat(search));\n      search.length === 1 || (search += '&');\n      search += \"jwt=\".concat(jwt);\n      url.search = search;\n    }\n  } // fragment/hash\n\n\n  var hash = url.hash;\n\n  for (var _i = 0, _arr = ['config', 'interfaceConfig', 'devices', 'userInfo']; _i < _arr.length; _i++) {\n    var urlPrefix = _arr[_i];\n\n    var urlParamsArray = _objectToURLParamsArray(o[\"\".concat(urlPrefix, \"Overwrite\")] || o[urlPrefix] || o[\"\".concat(urlPrefix, \"Override\")]);\n\n    if (urlParamsArray.length) {\n      var urlParamsString = \"\".concat(urlPrefix, \".\").concat(urlParamsArray.join(\"&\".concat(urlPrefix, \".\")));\n\n      if (hash.length) {\n        urlParamsString = \"&\".concat(urlParamsString);\n      } else {\n        hash = '#';\n      }\n\n      hash += urlParamsString;\n    }\n  }\n\n  url.hash = hash;\n  return url.toString() || undefined;\n}","map":{"version":3,"sources":["/home/sang/js/cfr-frontend/src/features/base/util/uri.js"],"names":["normalizeNFKC","APP_LINK_SCHEME","_ROOM_EXCLUDE_PATTERN","_URI_AUTHORITY_PATTERN","_URI_PATH_PATTERN","URI_PROTOCOL_PATTERN","_fixRoom","room","replace","RegExp","_fixURIStringScheme","uri","regex","match","exec","protocol","length","toLowerCase","substring","lastIndex","startsWith","getBackendSafeRoomName","decodeURIComponent","e","encodeURIComponent","getLocationContextRoot","pathname","contextRootEndIndex","lastIndexOf","_objectToURLParamsArray","obj","params","key","push","JSON","stringify","console","warn","parseStandardURIString","str","toString","_standardURIToString","authority","userinfoEndIndex","indexOf","host","portBeginIndex","port","hostname","hashBeginIndex","search","hash","parseURIString","undefined","contextRoot","fixedRoom","thiz","safeDecodeURIComponent","text","toURLString","URL","href","urlObjectToString","String","o","tmp","serverURL","url","scheme","endsWith","domain","roomName","jwt","urlPrefix","urlParamsArray","urlParamsString","join"],"mappings":"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","sourcesContent":["// @flow\n\nimport { normalizeNFKC } from './strings';\n\n/**\n * The app linking scheme.\n * TODO: This should be read from the manifest files later.\n */\nexport const APP_LINK_SCHEME = 'org.jitsi.meet:';\n\n/**\n * A list of characters to be excluded/removed from the room component/segment\n * of a conference/meeting URI/URL. The list is based on RFC 3986 and the jxmpp\n * library utilized by jicofo.\n */\nconst _ROOM_EXCLUDE_PATTERN = '[\\\\:\\\\?#\\\\[\\\\]@!$&\\'()*+,;=></\"]';\n\n/**\n * The {@link RegExp} pattern of the authority of a URI.\n *\n * @private\n * @type {string}\n */\nconst _URI_AUTHORITY_PATTERN = '(//[^/?#]+)';\n\n/**\n * The {@link RegExp} pattern of the path of a URI.\n *\n * @private\n * @type {string}\n */\nconst _URI_PATH_PATTERN = '([^?#]*)';\n\n/**\n * The {@link RegExp} pattern of the protocol of a URI.\n *\n * FIXME: The URL class exposed by JavaScript will not include the colon in\n * the protocol field. Also in other places (at the time of this writing:\n * the DeepLinkingMobilePage.js) the APP_LINK_SCHEME does not include\n * the double dots, so things are inconsistent.\n *\n * @type {string}\n */\nexport const URI_PROTOCOL_PATTERN = '^([a-z][a-z0-9\\\\.\\\\+-]*:)';\n\n/**\n * Excludes/removes certain characters from a specific room (name) which are\n * incompatible with Jitsi Meet on the client and/or server sides.\n *\n * @param {?string} room - The room (name) to fix.\n * @private\n * @returns {?string}\n */\nfunction _fixRoom(room) {\n    return room\n        ? room.replace(new RegExp(_ROOM_EXCLUDE_PATTERN, 'g'), '')\n        : room;\n}\n\n/**\n * Fixes the scheme part of a specific URI (string) so that it contains a\n * well-known scheme such as HTTP(S). For example, the mobile app implements an\n * app-specific URI scheme in addition to Universal Links. The app-specific\n * scheme may precede or replace the well-known scheme. In such a case, dealing\n * with the app-specific scheme only complicates the logic and it is simpler to\n * get rid of it (by translating the app-specific scheme into a well-known\n * scheme).\n *\n * @param {string} uri - The URI (string) to fix the scheme of.\n * @private\n * @returns {string}\n */\nfunction _fixURIStringScheme(uri) {\n    const regex = new RegExp(`${URI_PROTOCOL_PATTERN}+`, 'gi');\n    const match = regex.exec(uri);\n\n    if (match) {\n        // As an implementation convenience, pick up the last scheme and make\n        // sure that it is a well-known one.\n        let protocol = match[match.length - 1].toLowerCase();\n\n        if (protocol !== 'http:' && protocol !== 'https:') {\n            protocol = 'https:';\n        }\n\n        /* eslint-disable no-param-reassign */\n\n        uri = uri.substring(regex.lastIndex);\n        if (uri.startsWith('//')) {\n            // The specified URL was not a room name only, it contained an\n            // authority.\n            uri = protocol + uri;\n        }\n\n        /* eslint-enable no-param-reassign */\n    }\n\n    return uri;\n}\n\n/**\n * Converts a room name to a backend-safe format. Properly lowercased and url encoded.\n *\n * @param {string?} room - The room name to convert.\n * @returns {string?}\n */\nexport function getBackendSafeRoomName(room) {\n    if (!room) {\n        return room;\n    }\n\n    /* eslint-disable no-param-reassign */\n    try {\n        // We do not know if we get an already encoded string at this point\n        // as different platforms do it differently, but we need a decoded one\n        // for sure. However since decoding a non-encoded string is a noop, we're safe\n        // doing it here.\n        room = decodeURIComponent(room);\n    } catch (e) {\n        // This can happen though if we get an unencoded string and it contains\n        // some characters that look like an encoded entity, but it's not.\n        // But in this case we're fine goin on...\n    }\n\n    // Normalize the character set.\n    room = normalizeNFKC(room);\n\n    // Only decoded and normalized strings can be lowercased properly.\n    room = room.toLowerCase();\n\n    // But we still need to (re)encode it.\n    room = encodeURIComponent(room);\n    /* eslint-enable no-param-reassign */\n\n    // Unfortunately we still need to lowercase it, because encoding a string will\n    // add some uppercase characters, but some backend services\n    // expect it to be full lowercase. However lowercasing an encoded string\n    // doesn't change the string value.\n    return room.toLowerCase();\n}\n\n/**\n * Gets the (Web application) context root defined by a specific location (URI).\n *\n * @param {Object} location - The location (URI) which defines the (Web\n * application) context root.\n * @public\n * @returns {string} - The (Web application) context root defined by the\n * specified {@code location} (URI).\n */\nexport function getLocationContextRoot({ pathname }) {\n    const contextRootEndIndex = pathname.lastIndexOf('/');\n\n    return (\n        contextRootEndIndex === -1\n            ? '/'\n            : pathname.substring(0, contextRootEndIndex + 1));\n}\n\n/**\n * Constructs a new {@code Array} with URL parameter {@code String}s out of a\n * specific {@code Object}.\n *\n * @param {Object} obj - The {@code Object} to turn into URL parameter\n * {@code String}s.\n * @returns {Array<string>} The {@code Array} with URL parameter {@code String}s\n * constructed out of the specified {@code obj}.\n */\nfunction _objectToURLParamsArray(obj = {}) {\n    const params = [];\n\n    for (const key in obj) { // eslint-disable-line guard-for-in\n        try {\n            params.push(\n                `${key}=${encodeURIComponent(JSON.stringify(obj[key]))}`);\n        } catch (e) {\n            console.warn(`Error encoding ${key}: ${e}`);\n        }\n    }\n\n    return params;\n}\n\n/**\n * Parses a specific URI string into an object with the well-known properties of\n * the {@link Location} and/or {@link URL} interfaces implemented by Web\n * browsers. The parsing attempts to be in accord with IETF's RFC 3986.\n *\n * @param {string} str - The URI string to parse.\n * @public\n * @returns {{\n *     hash: string,\n *     host: (string|undefined),\n *     hostname: (string|undefined),\n *     pathname: string,\n *     port: (string|undefined),\n *     protocol: (string|undefined),\n *     search: string\n * }}\n */\nexport function parseStandardURIString(str) {\n    /* eslint-disable no-param-reassign */\n\n    const obj = {\n        toString: _standardURIToString\n    };\n\n    let regex;\n    let match;\n\n    // XXX A URI string as defined by RFC 3986 does not contain any whitespace.\n    // Usually, a browser will have already encoded any whitespace. In order to\n    // avoid potential later problems related to whitespace in URI, strip any\n    // whitespace. Anyway, the Jitsi Meet app is not known to utilize unencoded\n    // whitespace so the stripping is deemed safe.\n    str = str.replace(/\\s/g, '');\n\n    // protocol\n    regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');\n    match = regex.exec(str);\n    if (match) {\n        obj.protocol = match[1].toLowerCase();\n        str = str.substring(regex.lastIndex);\n    }\n\n    // authority\n    regex = new RegExp(`^${_URI_AUTHORITY_PATTERN}`, 'gi');\n    match = regex.exec(str);\n    if (match) {\n        let authority = match[1].substring(/* // */ 2);\n\n        str = str.substring(regex.lastIndex);\n\n        // userinfo\n        const userinfoEndIndex = authority.indexOf('@');\n\n        if (userinfoEndIndex !== -1) {\n            authority = authority.substring(userinfoEndIndex + 1);\n        }\n\n        obj.host = authority;\n\n        // port\n        const portBeginIndex = authority.lastIndexOf(':');\n\n        if (portBeginIndex !== -1) {\n            obj.port = authority.substring(portBeginIndex + 1);\n            authority = authority.substring(0, portBeginIndex);\n        }\n\n        // hostname\n        obj.hostname = authority;\n    }\n\n    // pathname\n    regex = new RegExp(`^${_URI_PATH_PATTERN}`, 'gi');\n    match = regex.exec(str);\n\n    let pathname;\n\n    if (match) {\n        pathname = match[1];\n        str = str.substring(regex.lastIndex);\n    }\n    if (pathname) {\n        pathname.startsWith('/') || (pathname = `/${pathname}`);\n    } else {\n        pathname = '/';\n    }\n    obj.pathname = pathname;\n\n    // query\n    if (str.startsWith('?')) {\n        let hashBeginIndex = str.indexOf('#', 1);\n\n        if (hashBeginIndex === -1) {\n            hashBeginIndex = str.length;\n        }\n        obj.search = str.substring(0, hashBeginIndex);\n        str = str.substring(hashBeginIndex);\n    } else {\n        obj.search = ''; // Google Chrome\n    }\n\n    // fragment\n    obj.hash = str.startsWith('#') ? str : '';\n\n    /* eslint-enable no-param-reassign */\n\n    return obj;\n}\n\n/**\n * Parses a specific URI which (supposedly) references a Jitsi Meet resource\n * (location).\n *\n * @param {(string|undefined)} uri - The URI to parse which (supposedly)\n * references a Jitsi Meet resource (location).\n * @public\n * @returns {{\n *     contextRoot: string,\n *     hash: string,\n *     host: string,\n *     hostname: string,\n *     pathname: string,\n *     port: string,\n *     protocol: string,\n *     room: (string|undefined),\n *     search: string\n * }}\n */\nexport function parseURIString(uri) {\n    if (typeof uri !== 'string') {\n        return undefined;\n    }\n\n    const obj = parseStandardURIString(_fixURIStringScheme(uri));\n\n    // Add the properties that are specific to a Jitsi Meet resource (location)\n    // such as contextRoot, room:\n\n    // contextRoot\n    obj.contextRoot = getLocationContextRoot(obj);\n\n    // The room (name) is the last component/segment of pathname.\n    const { pathname } = obj;\n\n    // XXX While the components/segments of pathname are URI encoded, Jitsi Meet\n    // on the client and/or server sides still don't support certain characters.\n    const contextRootEndIndex = pathname.lastIndexOf('/');\n    let room = pathname.substring(contextRootEndIndex + 1) || undefined;\n\n    if (room) {\n        const fixedRoom = _fixRoom(room);\n\n        if (fixedRoom !== room) {\n            room = fixedRoom;\n\n            // XXX Drive fixedRoom into pathname (because room is derived from\n            // pathname).\n            obj.pathname\n                = pathname.substring(0, contextRootEndIndex + 1) + (room || '');\n        }\n    }\n    obj.room = room;\n\n    return obj;\n}\n\n/**\n * Implements {@code href} and {@code toString} for the {@code Object} returned\n * by {@link #parseStandardURIString}.\n *\n * @param {Object} [thiz] - An {@code Object} returned by\n * {@code #parseStandardURIString} if any; otherwise, it is presumed that the\n * function is invoked on such an instance.\n * @returns {string}\n */\nfunction _standardURIToString(thiz) {\n    // eslint-disable-next-line no-invalid-this\n    const { hash, host, pathname, protocol, search } = thiz || this;\n    let str = '';\n\n    protocol && (str += protocol);\n\n    // TODO userinfo\n\n    host && (str += `//${host}`);\n    str += pathname || '/';\n    search && (str += search);\n    hash && (str += hash);\n\n    return str;\n}\n\n/**\n * Sometimes we receive strings that we don't know if already percent-encoded, or not, due to the\n * various sources we get URLs or room names. This function encapsulates the decoding in a safe way.\n *\n * @param {string} text - The text to decode.\n * @returns {string}\n */\nexport function safeDecodeURIComponent(text) {\n    try {\n        return decodeURIComponent(text);\n    } catch (e) {\n        // The text wasn't encoded.\n    }\n\n    return text;\n}\n\n/**\n * Attempts to return a {@code String} representation of a specific\n * {@code Object} which is supposed to represent a URL. Obviously, if a\n * {@code String} is specified, it is returned. If a {@code URL} is specified,\n * its {@code URL#href} is returned. Additionally, an {@code Object} similar to\n * the one accepted by the constructor of Web's ExternalAPI is supported on both\n * mobile/React Native and Web/React.\n *\n * @param {Object|string} obj - The URL to return a {@code String}\n * representation of.\n * @returns {string} - A {@code String} representation of the specified\n * {@code obj} which is supposed to represent a URL.\n */\nexport function toURLString(obj) {\n    let str;\n\n    // eslint-disable-next-line default-case\n    switch (typeof obj) {\n        case 'object':\n            if (obj) {\n                if (obj instanceof URL) {\n                    str = obj.href;\n                } else {\n                    str = urlObjectToString(obj);\n                }\n            }\n            break;\n\n        case 'string':\n            str = String(obj);\n            break;\n    }\n\n    return str;\n}\n\n/**\n * Attempts to return a {@code String} representation of a specific\n * {@code Object} similar to the one accepted by the constructor\n * of Web's ExternalAPI.\n *\n * @param {Object} o - The URL to return a {@code String} representation of.\n * @returns {string} - A {@code String} representation of the specified\n * {@code Object}.\n */\nexport function urlObjectToString(o) {\n    // First normalize the given url. It come as o.url or split into o.serverURL\n    // and o.room.\n    let tmp;\n\n    if (o.serverURL && o.room) {\n        tmp = new URL(o.room, o.serverURL).toString();\n    } else if (o.room) {\n        tmp = o.room;\n    } else {\n        tmp = o.url || '';\n    }\n\n    const url = parseStandardURIString(_fixURIStringScheme(tmp));\n\n    // protocol\n    if (!url.protocol) {\n        let protocol = o.protocol || o.scheme;\n\n        if (protocol) {\n            // Protocol is supposed to be the scheme and the final ':'. Anyway,\n            // do not make a fuss if the final ':' is not there.\n            protocol.endsWith(':') || (protocol += ':');\n            url.protocol = protocol;\n        }\n    }\n\n    // authority & pathname\n    let { pathname } = url;\n\n    if (!url.host) {\n        // Web's ExternalAPI domain\n        //\n        // It may be host/hostname and pathname with the latter denoting the\n        // tenant.\n        const domain = o.domain || o.host || o.hostname;\n\n        if (domain) {\n            const { host, hostname, pathname: contextRoot, port }\n                = parseStandardURIString(\n\n                    // XXX The value of domain in supposed to be host/hostname\n                    // and, optionally, pathname. Make sure it is not taken for\n                    // a pathname only.\n                    _fixURIStringScheme(`${APP_LINK_SCHEME}//${domain}`));\n\n            // authority\n            if (host) {\n                url.host = host;\n                url.hostname = hostname;\n                url.port = port;\n            }\n\n            // pathname\n            pathname === '/' && contextRoot !== '/' && (pathname = contextRoot);\n        }\n    }\n\n    // pathname\n\n    // Web's ExternalAPI roomName\n    const room = o.roomName || o.room;\n\n    if (room\n        && (url.pathname.endsWith('/')\n            || !url.pathname.endsWith(`/${room}`))) {\n        pathname.endsWith('/') || (pathname += '/');\n        pathname += room;\n    }\n\n    url.pathname = pathname;\n\n    // query/search\n\n    // Web's ExternalAPI jwt\n    const { jwt } = o;\n\n    if (jwt) {\n        let { search } = url;\n\n        if (search.indexOf('?jwt=') === -1 && search.indexOf('&jwt=') === -1) {\n            search.startsWith('?') || (search = `?${search}`);\n            search.length === 1 || (search += '&');\n            search += `jwt=${jwt}`;\n\n            url.search = search;\n        }\n    }\n\n    // fragment/hash\n\n    let { hash } = url;\n\n    for (const urlPrefix of ['config', 'interfaceConfig', 'devices', 'userInfo']) {\n        const urlParamsArray\n            = _objectToURLParamsArray(\n                o[`${urlPrefix}Overwrite`]\n                || o[urlPrefix]\n                || o[`${urlPrefix}Override`]);\n\n        if (urlParamsArray.length) {\n            let urlParamsString\n                = `${urlPrefix}.${urlParamsArray.join(`&${urlPrefix}.`)}`;\n\n            if (hash.length) {\n                urlParamsString = `&${urlParamsString}`;\n            } else {\n                hash = '#';\n            }\n            hash += urlParamsString;\n        }\n    }\n\n    url.hash = hash;\n\n    return url.toString() || undefined;\n}\n"]},"metadata":{},"sourceType":"module"}