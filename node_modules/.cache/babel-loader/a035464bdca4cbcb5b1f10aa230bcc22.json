{"ast":null,"code":"import { MEDIA_DEVICE_TYPES, webrtcKindToJitsiKindTranslator } from '../constants';\nexport * from './audio';\nexport * from './device-permissions';\nexport * from './utils';\nexport function getDeviceById(availableDevices, id) {\n  var device = availableDevices.find(function (d) {\n    return d.deviceId === id;\n  });\n  if (device) return device;\n}\n/**\n * Finds a device with a label that matches the passed label and returns its id.\n *\n * @param {Object} availableDevices - The mobx availableDevices object.\n * @param {string} label - The label.\n * @param {string} kind - The type of the device. One of \"audioInput\", \"audioOutput\", and \"videoInput\".\n * Also supported is all lowercase versions of the preceding types.\n */\n\nexport function getDeviceIdByLabel(availableDevices, label, kind) {\n  var kindToSearch = webrtcKindToJitsiKindTranslator[kind] || kind;\n  var device = availableDevices[kindToSearch].find(function (d) {\n    return d.label === label;\n  });\n  if (device) return device.deviceId;\n}\n/**\n * Finds a device with a label that matches the passed id and returns its label.\n *\n * @param {Object} availableDevices - The mobx availableDevices object.\n * @param {string} id - The device id.\n * @param {string} kind - The type of the device. One of \"audioInput\", \"audioOutput\", and \"videoInput\".\n * Also supported is all lowercase versions of the preceding types.\n * @returns {string|undefined}\n */\n\nexport function getDeviceLabelById(availableDevices, id, kind) {\n  var kindToSearch = webrtcKindToJitsiKindTranslator[kind] || kind;\n  var device = availableDevices[kindToSearch].find(function (d) {\n    return d.deviceId === id;\n  });\n  if (device) return device.label;\n}\n/**\n * Converts an array of media devices into an object organized by device kind.\n *\n * @param {Array<MediaDeviceInfo>} devices - Available media devices.\n * @returns An object with the media devices split by type. The keys are device type\n * and the values are arrays with devices matching the device type.\n */\n\nexport function groupDevicesByKind(availableDevices) {\n  return {\n    audioInput: availableDevices.filter(function (device) {\n      return device.kind === MEDIA_DEVICE_TYPES.AUDIO_INPUT;\n    }),\n    audioOutput: availableDevices.filter(function (device) {\n      return device.kind === MEDIA_DEVICE_TYPES.AUDIO_OUTPUT;\n    }),\n    videoInput: availableDevices.filter(function (device) {\n      return device.kind === MEDIA_DEVICE_TYPES.VIDEO_INPUT;\n    })\n  };\n}\n/**\n * We want to strip any device details that are not very user friendly, like usb ids put in brackets at the end.\n *\n * @param {string} label - Device label to format.\n * @returns  - Formatted string.\n */\n\nexport function formatDeviceLabel(label) {\n  var formattedLabel = label; // Remove braked description at the end as it contains non user friendly strings i.e.\n  // Microsoft® LifeCam HD-3000 (045e:0779:31dg:d1231)\n\n  var ix = formattedLabel.lastIndexOf('(');\n\n  if (ix !== -1) {\n    formattedLabel = formattedLabel.substr(0, ix);\n  }\n\n  return formattedLabel;\n}","map":{"version":3,"sources":["/home/sang/js/cfr-frontend/src/pages/conference2/jitsi/devices/index.ts"],"names":["MEDIA_DEVICE_TYPES","webrtcKindToJitsiKindTranslator","getDeviceById","availableDevices","id","device","find","d","deviceId","getDeviceIdByLabel","label","kind","kindToSearch","getDeviceLabelById","groupDevicesByKind","audioInput","filter","AUDIO_INPUT","audioOutput","AUDIO_OUTPUT","videoInput","VIDEO_INPUT","formatDeviceLabel","formattedLabel","ix","lastIndexOf","substr"],"mappings":"AAAA,SAASA,kBAAT,EAA6BC,+BAA7B,QAAoE,cAApE;AAEA,cAAc,SAAd;AACA,cAAc,sBAAd;AACA,cAAc,SAAd;AAeA,OAAO,SAASC,aAAT,CAAuBC,gBAAvB,EAA6DC,EAA7D,EAAkG;AACvG,MAAMC,MAAM,GAAGF,gBAAgB,CAACG,IAAjB,CAAsB,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACC,QAAF,KAAeJ,EAAnB;AAAA,GAAvB,CAAf;AACA,MAAIC,MAAJ,EAAY,OAAOA,MAAP;AACb;AAED;;;;;;;;;AAQA,OAAO,SAASI,kBAAT,CACLN,gBADK,EAELO,KAFK,EAGLC,IAHK,EAIe;AACpB,MAAMC,YAAY,GAAGX,+BAA+B,CAACU,IAAD,CAA/B,IAAyCA,IAA9D;AAEA,MAAMN,MAAM,GAAGF,gBAAgB,CAACS,YAAD,CAAhB,CAA+BN,IAA/B,CAAoC,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACG,KAAF,KAAYA,KAAhB;AAAA,GAArC,CAAf;AAEA,MAAIL,MAAJ,EAAY,OAAOA,MAAM,CAACG,QAAd;AACb;AAED;;;;;;;;;;AASA,OAAO,SAASK,kBAAT,CACLV,gBADK,EAELC,EAFK,EAGLO,IAHK,EAIe;AACpB,MAAMC,YAAY,GAAGX,+BAA+B,CAACU,IAAD,CAA/B,IAAyCA,IAA9D;AAEA,MAAMN,MAAM,GAAGF,gBAAgB,CAACS,YAAD,CAAhB,CAA+BN,IAA/B,CAAoC,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACC,QAAF,KAAeJ,EAAnB;AAAA,GAArC,CAAf;AAEA,MAAIC,MAAJ,EAAY,OAAOA,MAAM,CAACK,KAAd;AACb;AAED;;;;;;;;AAOA,OAAO,SAASI,kBAAT,CAA4BX,gBAA5B,EAAkE;AACvE,SAAO;AACLY,IAAAA,UAAU,EAAEZ,gBAAgB,CAACa,MAAjB,CAAwB,UAAAX,MAAM;AAAA,aAAIA,MAAM,CAACM,IAAP,KAAgBX,kBAAkB,CAACiB,WAAvC;AAAA,KAA9B,CADP;AAELC,IAAAA,WAAW,EAAEf,gBAAgB,CAACa,MAAjB,CAAwB,UAAAX,MAAM;AAAA,aAAIA,MAAM,CAACM,IAAP,KAAgBX,kBAAkB,CAACmB,YAAvC;AAAA,KAA9B,CAFR;AAGLC,IAAAA,UAAU,EAAEjB,gBAAgB,CAACa,MAAjB,CAAwB,UAAAX,MAAM;AAAA,aAAIA,MAAM,CAACM,IAAP,KAAgBX,kBAAkB,CAACqB,WAAvC;AAAA,KAA9B;AAHP,GAAP;AAKD;AAED;;;;;;;AAMA,OAAO,SAASC,iBAAT,CAA2BZ,KAA3B,EAA0C;AAC/C,MAAIa,cAAc,GAAGb,KAArB,CAD+C,CAG/C;AACA;;AACA,MAAMc,EAAE,GAAGD,cAAc,CAACE,WAAf,CAA2B,GAA3B,CAAX;;AAEA,MAAID,EAAE,KAAK,CAAC,CAAZ,EAAe;AACbD,IAAAA,cAAc,GAAGA,cAAc,CAACG,MAAf,CAAsB,CAAtB,EAAyBF,EAAzB,CAAjB;AACD;;AAED,SAAOD,cAAP;AACD","sourcesContent":["import { MEDIA_DEVICE_TYPES, webrtcKindToJitsiKindTranslator } from '../constants'\n\nexport * from './audio'\nexport * from './device-permissions'\nexport * from './utils'\n\nexport interface AvailableMediaDevices {\n  audioInput: Array<MediaDevice>\n  audioOutput: Array<MediaDevice>\n  videoInput: Array<MediaDevice>\n}\n\nexport interface MediaDevice {\n  deviceId: string\n  groupId: string\n  kind: string\n  label: string\n}\n\nexport function getDeviceById(availableDevices: Array<MediaDevice>, id: string): MediaDevice | undefined {\n  const device = availableDevices.find(d => d.deviceId === id)\n  if (device) return device\n}\n\n/**\n * Finds a device with a label that matches the passed label and returns its id.\n *\n * @param {Object} availableDevices - The mobx availableDevices object.\n * @param {string} label - The label.\n * @param {string} kind - The type of the device. One of \"audioInput\", \"audioOutput\", and \"videoInput\".\n * Also supported is all lowercase versions of the preceding types.\n */\nexport function getDeviceIdByLabel(\n  availableDevices: AvailableMediaDevices,\n  label: string,\n  kind: string\n): string | undefined {\n  const kindToSearch = webrtcKindToJitsiKindTranslator[kind] || kind\n\n  const device = availableDevices[kindToSearch].find(d => d.label === label)\n\n  if (device) return device.deviceId\n}\n\n/**\n * Finds a device with a label that matches the passed id and returns its label.\n *\n * @param {Object} availableDevices - The mobx availableDevices object.\n * @param {string} id - The device id.\n * @param {string} kind - The type of the device. One of \"audioInput\", \"audioOutput\", and \"videoInput\".\n * Also supported is all lowercase versions of the preceding types.\n * @returns {string|undefined}\n */\nexport function getDeviceLabelById(\n  availableDevices: AvailableMediaDevices,\n  id: string,\n  kind: string\n): string | undefined {\n  const kindToSearch = webrtcKindToJitsiKindTranslator[kind] || kind\n\n  const device = availableDevices[kindToSearch].find(d => d.deviceId === id)\n\n  if (device) return device.label\n}\n\n/**\n * Converts an array of media devices into an object organized by device kind.\n *\n * @param {Array<MediaDeviceInfo>} devices - Available media devices.\n * @returns An object with the media devices split by type. The keys are device type\n * and the values are arrays with devices matching the device type.\n */\nexport function groupDevicesByKind(availableDevices: Array<MediaDevice>) {\n  return {\n    audioInput: availableDevices.filter(device => device.kind === MEDIA_DEVICE_TYPES.AUDIO_INPUT),\n    audioOutput: availableDevices.filter(device => device.kind === MEDIA_DEVICE_TYPES.AUDIO_OUTPUT),\n    videoInput: availableDevices.filter(device => device.kind === MEDIA_DEVICE_TYPES.VIDEO_INPUT)\n  }\n}\n\n/**\n * We want to strip any device details that are not very user friendly, like usb ids put in brackets at the end.\n *\n * @param {string} label - Device label to format.\n * @returns  - Formatted string.\n */\nexport function formatDeviceLabel(label: string) {\n  let formattedLabel = label\n\n  // Remove braked description at the end as it contains non user friendly strings i.e.\n  // Microsoft® LifeCam HD-3000 (045e:0779:31dg:d1231)\n  const ix = formattedLabel.lastIndexOf('(')\n\n  if (ix !== -1) {\n    formattedLabel = formattedLabel.substr(0, ix)\n  }\n\n  return formattedLabel\n}\n"]},"metadata":{},"sourceType":"module"}